# Because autoscaler can talk to itself using websockets, we must also enforce
# strict mTLS again via DestinationRule. Otherwise, if the websocket client is the same
# as the destination pod, the connection will fail, because it does not use mTLS.
apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: force-mtls
  namespace: knative-serving
spec:
  host: "*.knative-serving.svc.cluster.local"
  trafficPolicy:
    tls:
      mode: ISTIO_MUTUAL
---
# The peer-authentication.yaml enables mTLS for the whole mesh, but
# as this is not working for DomainMappings, these DestinationRules enforce mTLS also on the service level.
# This forces the istio-ingressgateway to also send mTLS if the destination is itself.
apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: force-mtls
  namespace: tenant-1
spec:
  host: "*.tenant-1.svc.cluster.local"
  trafficPolicy:
    tls:
      mode: ISTIO_MUTUAL
---
apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: force-mtls
  namespace: tenant-2
spec:
  host: "*.tenant-2.svc.cluster.local"
  trafficPolicy:
    tls:
      mode: ISTIO_MUTUAL
---
